@using Microsoft.AspNetCore.Components.Rendering
@using System.Linq.Expressions
@typeparam TGridItem
@attribute [CascadingTypeParameter(nameof(TGridItem))]
@inject IJSRuntime JS
@implements IAsyncDisposable
<CascadingValue IsFixed="true" Value="@_internalGridContext">
    @{
        _columns.Clear();
    }
    @ChildContent
    <Defer>
        <table class="quickgrid @Class" theme="@Theme" aria-rowcount="@(_rowCount + 1)" @ref="_tableReference" @onclosecolumnoptions="CloseColumnOptions" resizable-columns="@ResizableColumns">
            <thead>
                <tr>
                    @RenderColumnHeaders
                </tr>
            </thead>
            <tbody>
                @if (Virtualize)
                {
                    <Virtualize @ref="@_virtualizeComponent"
                            TItem="(int RowIndex, TGridItem Data)"
                            ItemSize="@ItemSize"
                            ItemsProvider="@ProvideVirtualizedItems"
                            ItemContent="@(item => builder => RenderRow(builder, item.RowIndex, item.Data))" />
                }
                else
                {
                    @RenderRows
                }
            </tbody>
        </table>
    </Defer>
</CascadingValue>

@code {
    [Parameter, EditorRequired] public IQueryable<TGridItem>? Items { get; set; }
    [Parameter] public string? Class { get; set; }
    [Parameter] public string? Theme { get; set; } = "default";
    [Parameter] public RenderFragment? ChildContent { get; set; }
    [Parameter] public bool Virtualize { get; set; }
    [Parameter] public bool ResizableColumns { get; set; }
    [Parameter] public float ItemSize { get; set; } = 50;
    [Parameter] public Func<TGridItem, object> ItemKey { get; set; } = x => x;
    [Parameter] public PaginationState? Pagination { get; set; }

    private Virtualize<(int, TGridItem)>? _virtualizeComponent;
    private List<ColumnBase<TGridItem>> _columns;
    private ColumnBase<TGridItem>? _sortByColumn;
    private ColumnBase<TGridItem>? _displayOptionsForColumn;
    private bool _checkColumnOptionsPosition;
    private bool _sortByAscending;
    private int _rowCount;
    private IJSObjectReference? _jsModule;
    private IJSObjectReference? _jsEventDisposable;
    private ElementReference _tableReference;
    private InternalGridContext<TGridItem> _internalGridContext;

    // This is the final filtered and sorted data to be rendered.
    // We update it asynchronously each time the sort order changes, or if an external
    // component like Paginator tells us to do so. We only render after this has been updated.
    private IEnumerable<TGridItem> _currentViewItems = Enumerable.Empty<TGridItem>();
    private int _lastRefreshedPaginationStateHash;
    private IQueryable<TGridItem>? _lastRefreshedItems;
    private long _latestDataLoadIdentifier;

    public QuickGrid()
    {
        _columns = new();
        _internalGridContext = new(this);
    }

    public async Task RefreshDataAsync()
    {
        var thisDataLoadIdentifier = ++_latestDataLoadIdentifier;
        _lastRefreshedItems = Items;

        // Querying may be expensive (especially if it's not in-memory data), so we only update
        // the currently-rendered row data when explicitly asked, or when an event occurs that
        // specifically changes the data, such as sorting.
        if (_virtualizeComponent is not null)
        {
            // This will call back into ProvideVirtualizedItems
            await _virtualizeComponent.RefreshDataAsync();
        }
        else
        {
            // TODO: Support a whole alternative mechanism for non-IQueryable data sources
            var result = Items;
            if (result is null)
            {
                _currentViewItems = Enumerable.Empty<TGridItem>();
                _rowCount = 0;
                return;
            }

            if (_sortByColumn is not null)
            {
                result = _sortByColumn.ApplyColumnSort(result, _sortByAscending);
            }

            if (Pagination is not null)
            {
                result = Pagination.ApplyPagination(result);
                _lastRefreshedPaginationStateHash = Pagination.GetHashCode();
            }

            await Task.Delay(500); // Temporary: Simulate query duration to verify this makes sense

            if (thisDataLoadIdentifier == _latestDataLoadIdentifier)
            {
                // TODO: in case you're using EF Core, we really want to call ToListAsync. That's an extension
                // method defined in Microsoft.EntityFrameworkCore on IQueryable<T>. But we don't want to couple QuickGrid
                // to EF Core generally, as that's too much extra code on WebAssembly if you're not using it (and wouldn't
                // be trimmable if we referenced it here). May need some extra package you can reference optionally to act
                // as an adapter.
                _currentViewItems = result.ToList()!;
                _rowCount = Items!.Count();
            }
        }
    }

    // Invoked by descendant columns at a special time during rendering
    internal void AddColumn(ColumnBase<TGridItem> column)
    {
        _columns.Add(column);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            _jsModule = await JS.InvokeAsync<IJSObjectReference>("import", "./_content/Microsoft.AspNetCore.Components.QuickGrid/QuickGrid.razor.js");
            _jsEventDisposable = await _jsModule.InvokeAsync<IJSObjectReference>("init", _tableReference);
        }

        if (_checkColumnOptionsPosition && _displayOptionsForColumn is not null)
        {
            _checkColumnOptionsPosition = false;
            _ = _jsModule?.InvokeVoidAsync("checkColumnOptionsPosition", _tableReference);
        }
    }

    protected override Task OnParametersSetAsync()
    {
        var mustRefreshData = Items != _lastRefreshedItems
            || (Pagination is not null && Pagination.GetHashCode() != _lastRefreshedPaginationStateHash);

        return mustRefreshData ? RefreshDataAsync() : Task.CompletedTask;
    }

    private void RenderRows(RenderTreeBuilder __builder)
    {
        var initialRowIndex = 2; // aria-rowindex is 1-based, plus the first row is the header
        var rowIndex = initialRowIndex; 
        foreach (var item in _currentViewItems)
        {
            RenderRow(__builder, rowIndex++, item);
        }

        // When pagination is enabled, by default ensure we render the exact number of expected rows per page,
        // even if there aren't enough data items. This avoids the layout jumping on the last page.
        // Consider making this optional.
        if (Pagination is not null)
        {
            while (rowIndex++ < initialRowIndex + Pagination.ItemsPerPage)
            {
                <tr></tr>
            }
        }
    }

    private void RenderRow(RenderTreeBuilder __builder, int rowIndex, TGridItem item)
    {
        <tr @key="@(ItemKey(item))" aria-rowindex="@rowIndex">
            @foreach (var col in _columns)
            {
                <td class="@ColumnClass(col)" @key="@col">@{ col.CellContent(__builder, item); }</td>                
                <td class="col-gap"></td>
            }
        </tr>
    }

    private void RenderColumnHeaders(RenderTreeBuilder __builder)
    {
        foreach (var col in _columns)
        {
            <th class="@ColumnHeaderClass(col)" aria-sort="@AriaSortValue(col)" @key="@col" scope="col">
                <div class="col-header-content">@col.HeaderContent</div>

                @if (col == _displayOptionsForColumn)
                {
                    <div class="col-options">@col.ColumnOptions</div>
                }
            </th>
            <th class="col-gap"></th>
        }
    }

    private string AriaSortValue(ColumnBase<TGridItem> column)
        => _sortByColumn == column
            ? (_sortByAscending ? "ascending" : "descending")
            : "none";

    private string? ColumnHeaderClass(ColumnBase<TGridItem> column)
        => _sortByColumn == column
        ? $"{ColumnClass(column)} {(_sortByAscending ? "col-sort-asc" : "col-sort-desc")}"
        : ColumnClass(column);

    private string? ColumnClass(ColumnBase<TGridItem> column)
    {
        switch (column.Align)
        {
            case Align.Center: return $"col-justify-center {column.Class}";
            case Align.Right: return $"col-justify-end {column.Class}";
            default: return column.Class;
        }
    }

    public async Task SortByColumnAsync(ColumnBase<TGridItem> column, SortDirection direction = SortDirection.Auto)
    {
        _sortByAscending = direction switch
        {
            SortDirection.Ascending => true,
            SortDirection.Descending => false,
            SortDirection.Auto => _sortByColumn == column ? !_sortByAscending : true,
            _ => throw new NotSupportedException($"Unknown sort direction { direction }"),
        };

        _sortByColumn = column;

        if (_virtualizeComponent is not null)
        {
            await _virtualizeComponent.RefreshDataAsync();
        }

        StateHasChanged();
    }

    public void ShowColumnOptions(ColumnBase<TGridItem> column)
    {
        _displayOptionsForColumn = column;
        _checkColumnOptionsPosition = true;
        StateHasChanged();
    }

    private async ValueTask<ItemsProviderResult<(int, TGridItem)>> ProvideVirtualizedItems(ItemsProviderRequest request)
    {
        if (Items is null)
        {
            return new ItemsProviderResult<(int, TGridItem)>(Enumerable.Empty<(int, TGridItem)>(), 0);
        }
        else
        {
            // Debounce the requests. This eliminates a lot of redundant queries at the cost of slight lag after interactions.
            // If you wanted, you could try to make it only debounce on the 2nd-and-later request within a cluster.
            await Task.Delay(20);
            if (request.CancellationToken.IsCancellationRequested)
            {
                return default;
            }

            var records = _currentViewItems.Skip(request.StartIndex).Take(request.Count).AsEnumerable();
            _rowCount = Items.Count();
            var result = new ItemsProviderResult<(int, TGridItem)>(
                items: records.Select((x, i) => ValueTuple.Create(i + request.StartIndex + 2, x)),
                totalItemCount: _rowCount);
            return result;
        }
    }

    public async ValueTask DisposeAsync()
    {
        try
        {
            if (_jsEventDisposable is not null)
            {
                await _jsEventDisposable.InvokeVoidAsync("stop");
                await _jsEventDisposable.DisposeAsync();
            }
            if (_jsModule is not null)
            {
                await _jsModule.DisposeAsync();
            }
        }
        catch
        {
        }
    }

    void CloseColumnOptions()
    {
        _displayOptionsForColumn = null;
    }
}
